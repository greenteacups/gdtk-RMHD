-- grid.lua
-- lmr(5) script for Langley Expansion Tube simulation
--
-- Author: Rowan J. Gollan and Peter J.
-- Date: 2024-07-29 (adapted from Eilmer4 example)
--
-- This script is used to emulate Case 1 described in:
--
-- Jacobs, P.A. (1994)
-- Numerical Simulation of Transient Hypervelocity Flow in an Expansion Tube
-- Computers & Fluids, 23:1 pp. 77--101
--
print("Langley Expansion Tube, Case 1")
config.dimensions = 2
config.axisymmetric = true
config.viscous = true
config.grid_format = 'rawbinary'
--
dofile('./geom.lua')
quad0 = CoonsPatch:new{p00=A1, p10=B1, p11=B2, p01=A2}
quad1 = CoonsPatch:new{p00=A0, p10=B0, p11=B1, p01=A1}
quad2 = CoonsPatch:new{p00=B0, p10=C0, p11=C1, p01=B1}
quad3 = CoonsPatch:new{p00=C0, p10=D0, p11=D1, p01=C1}
--
-- Original grid on Cray-Y/MP was 2404x30.
-- Distribute the cells between the three segments.
factor = 1
nxcells_total = math.floor(factor*2406)
nxcells_d = math.floor((L_d/L_total)*nxcells_total + 0.5)
nxcells_i = math.floor((L_i/L_total)*nxcells_total + 0.5)
nxcells_a = math.floor((L_a/L_total)*nxcells_total + 0.5)
print("nxcells in driver: ", nxcells_d)
print("nxcells in int.: ", nxcells_i)
print("nxcells in acc.: ", nxcells_a)
print("total= ", nxcells_d + nxcells_i + nxcells_a)
--
nycells_driven = math.floor(factor*30)
beta = 1.1
nycells_extra = math.floor(factor*8)
--
clusterToWall = RobertsFunction:new{end0=false, end1=true, beta=beta}
--
grid0 = StructuredGrid:new{psurface=quad0, niv=nxcells_d+1, njv=nycells_extra+1}
grid1 = StructuredGrid:new{psurface=quad1, niv=nxcells_d+1, njv=nycells_driven+1,
                           cfList={west=clusterToWall, east=clusterToWall}}
grid2 = StructuredGrid:new{psurface=quad2, niv=nxcells_i+1, njv=nycells_driven+1,
                           cfList={west=clusterToWall, east=clusterToWall}}
grid3 = StructuredGrid:new{psurface=quad3, niv=nxcells_a+1, njv=nycells_driven+1,
                           cfList={west=clusterToWall, east=clusterToWall}}
-- Subdivide the grids so that we can run in parallel.
factorB = 1
nib_d = math.floor(2*factorB)
nib_i = math.floor(nib_d*L_i/L_d)
nib_a = math.floor(nib_d*L_a/L_d)
nblocks_total = nib_d*2 + nib_i + nib_a
print("total number of blocks= ", nblocks_total)
registerFluidGridArray{grid=grid0, fsTag='driver_gas', nib=nib_d, njb=1,
                       bcTags={north='warmWall', west='warmWall', east='warmWall'}}
registerFluidGridArray{grid=grid1, fsTag='driver_gas', nib=nib_d, njb=1,
                       bcTags={west='warmWall'}}
registerFluidGridArray{grid=grid2, fsTag='test_gas', nib=nib_i, njb=1,
                       bcTags={north='coldWall', east='upstream_face_of_diaphragm'}}
registerFluidGridArray{grid=grid3, fsTag='acceleration_gas', nib=nib_a, njb=1,
                       bcTags={north='coldWall', east='outFlow',
                               west='downstream_face_of_diaphragm'}}
-- identifyGridConnections()
-- Blanket use of identifyGridConnections() will overwrite
-- the custom diaphragm connection, so connect the grids explicitly.
for i=1, nib_d do
   connectGrids(gridArraysList[1].myGrids[i][1].id, 'south',
                gridArraysList[2].myGrids[i][1].id, 'north')
end
connectGrids(gridArraysList[2].myGrids[nib_d][1].id, 'east',
             gridArraysList[3].myGrids[1][1].id, 'west')
--
-- We want to tell the other scripts which blocks
-- are upstream and downstream of the secondary diaphragm.
f = io.open('blkIds.lua', 'w')
f:write("-- Secondary diaphragm block identities.\n")
f:write("-- Note that is file is generated by the grid.lua script.\n")
f:write(string.format("upstreamBlk = %d\n", gridArraysList[3].myGrids[nib_i][1].id))
f:write(string.format("downstreamBlk = %d\n", gridArraysList[4].myGrids[1][1].id))
f:close()
